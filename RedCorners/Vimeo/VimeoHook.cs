using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Threading.Tasks;
using SimpleJSON;
using static RedCorners.Core;

namespace RedCorners.Vimeo
{
    public partial class VimeoHook
    {
        string clientId;
        string apiRoot;
        string redirect;

        public static Action<string> VerboseCallback = null;
        public Action<VerifyFeedback> UploadCallback = null;

        /// <summary>
        /// This contains all JSON data that is received after login.
        /// </summary>
        public JSONNode AccessJson { get; private set; }

        /// <summary>
        /// User data. contains information such as display name, user uri, etc.
        /// </summary>
        public JSONNode User { get; private set; }

        /// <summary>
        /// Access token after login. Save this for relogins.
        /// </summary>
        public string AccessToken { get; private set; }

        /// <summary>
        /// Scopes (permissions) you have. e.g. "private public"
        /// </summary>
        //public 
        string[] Scope { get; set; }

        /// <summary>
        /// token_type. e.g. "bearer"
        /// </summary>
        //public 
        string TokenType { get; set; }

        async Task LoadAccessDataAsync()
        {
            AccessToken = AccessJson["access_token"].Value;
            Scope = AccessJson["scope"].Value.Split(' ');
            TokenType = AccessJson["token_type"].Value;
            User = await RequestAsync("/me", null, "GET");
        }

        /// <summary>
        /// Generates a new access token given the authorization code generated by the page
        /// at get_auth_url().
        ///
        /// In the context of a web server, the programmer should retrieve the auth_code
        /// generated by the page at get_auth_url() and use it as the input to this function.
        /// The programmer should then use the string returned from this function to
        /// authenticate calls to the API library on behalf of the corresponding user.
        ///
        /// Note: The following URLs must be identical:
        /// This function's redirect parameter
        /// The redirect parameter passed to get_access_token
        /// One of the redirect URIs listed on the app setup page
        /// </summary>
        /// <param name="authCode">The authorization code given in the 'code' query parameter of the page URI after redirecting from the result of get_auth_url</param>
        /// <param name="clientId">The client ID for the current app</param>
        /// <param name="secret">The client secret for the current app</param>
        /// <param name="redirect">The redirect URI for the app (see note)</param>
        /// <param name="apiRoot">The root url of the API being used (in OldVimeoClient, accessible via config['apiroot'])</param>
        /// <returns>Access Token JSON. result["access_token"] contains access token in string</returns>
        static async Task<JSONNode> GetAccessTokenAsync(
            string authCode, string clientId, string secret, string redirect, string apiRoot = "https://api.vimeo.com")
        {
            string encoded = Core.ToBase64(String.Format("{0}:{1}", clientId, secret));
            Debug.WriteLine(String.Format("Encoded: {0}", encoded));

            var payload = new Dictionary<string, object>
            {
                {"grant_type", "authorization_code"},
                {"code", authCode},
                {"redirect_uri", redirect}
            };
            var headers = new WebHeaderCollection
            {
                {"Authorization", String.Format("Basic {0}", encoded)}
            };
            
            var response = await HTTPFetchAsync(
                String.Format("{0}/oauth/access_token", apiRoot),
                "POST", headers, payload);

            VerboseCallback?.Invoke(response);
            return JSON.Parse(response);
        }
        
        public static async Task<string> GetClientCredentialsAsync(string clientId, string clientSecret, string scopes = null, string apiRoot = "https://api.vimeo.com")
        {
            var basicAuth = Core.ToBase64(string.Format("{0}:{1}", clientId, clientSecret));
            var payload = new Dictionary<string, object>
            {
                {"grant_type", "client_credentials"}
            };
            var headers = new WebHeaderCollection
            {
                //{"Accept", "application/vnd.vimeo.*+json; version=3.2"},
                {"Authorization", String.Format("Basic {0}", basicAuth)}
            };
            if (scopes != null) payload.Add("scope", scopes);
            var response = await HTTPFetchAsync(String.Format("{0}/oauth/authorize/client", apiRoot),
                "POST", headers, payload);

            var json = JSON.Parse(response);
            return json["access_token"];
        }
        
        public static async Task<VimeoHook> AuthorizeAsync(
        string authCode,
        string clientId,
        string secret,
        string redirect,
        string apiRoot = "https://api.vimeo.com")
        {
            VimeoHook vc = new VimeoHook();
            vc.clientId = clientId;
            vc.apiRoot = apiRoot;
            vc.redirect = redirect;
            vc.AccessJson = await GetAccessTokenAsync(authCode, clientId, secret, redirect, apiRoot);
            await vc.LoadAccessDataAsync();

            return vc;
        }
        
        public static async Task<VimeoHook> ReAuthorizeAsync(
            string accessToken,
            string clientId,
            string redirect="",
            string apiRoot = "https://api.vimeo.com")
        {
            VimeoHook vc = new VimeoHook();
            vc.clientId = clientId;
            vc.redirect = redirect;
            vc.AccessToken = accessToken;
            vc.apiRoot = apiRoot;
            vc.User = await vc.RequestAsync("/me", null, "GET");
            if (vc.User["error"].Value.Length > 0) throw new Exception(vc.User["error"]);

            return vc;
        }
        
        public static string GetLoginURL(
            string clientId,
            List<string> scopes = null,
            string redirect = "",
            string apiRoot = "https://api.vimeo.com")
        {
            List<string> choices = new List<string>{"interact", "private", "public", "create",
                "edit", "delete", "upload"};
            string authUrl = String.Format("{0}/oauth/authorize?response_type=code&client_id={1}&scope=",
                apiRoot, clientId);

            if (scopes == null) scopes = choices;
            foreach (var scope in scopes)
            {
                if (!choices.Contains(scope))
                    throw new FormatException(String.Format("Scope must be one of {0} (found scope '{1}')", choices, scope));
                authUrl += String.Format("{0}+", scope);
            }
            authUrl += String.Format("&redirect_uri={0}", redirect);
            return authUrl;
        }


        /// <summary>
        /// This is your portal to Vimeo. Use it to call a method with a bunch of parameters.
        /// Example: get your own profile by calling 
        /// Request("/me", null, "GET")
        /// </summary>
        /// <param name="url">The endpoint. It should be a relative URL specifying the API method you want to call, such as "/me"</param>
        /// <param name="parameters">Call parameters. Put null if you don't feel like it.</param>
        /// <param name="method">HTTP method: e.g. "GET", "POST", "PUT", etc.</param>
        /// <param name="jsonBody">true: set content type to json</param>
        /// <returns>Deserialized JSON as Dictionary of strings to objects</returns>
        public async Task<JSONNode> RequestAsync(
            string url,
            Dictionary<string, object> parameters,
            string method,
            bool jsonBody = true)
        {
            string body = "";

            if (parameters != null && parameters.Count > 0)
            {
                if (method == "GET")
                {
                    url += "?" + Core.KeyValueToString(parameters);
                }
                else if (method == "POST" || method == "PATCH" || method == "PUT" || method == "DELETE")
                {
                    if (jsonBody)
                    {
                        body = Core.JsonEncode(parameters);
                    }
                    else
                    {
                        body = Core.KeyValueToString(parameters);
                    }
                }
            }

            return await RequestAsync(url, method, jsonBody, body);
        }
        
        public async Task<JSONNode> RequestAsync(
            string url,
            string method,
            bool jsonBody,
            string body)
        {
            string fetch = await RequestRawAsync(url, method, jsonBody, body);
            return JSON.Parse(fetch);
        }

        public async Task<HTTPFetchResponse> RequestRawAsync(
            string url,
            string method,
            bool jsonBody,
            string body)
        {
            string contentType = "application/x-www-form-urlencoded";
            if (jsonBody) contentType = "application/json";
            var headers = new WebHeaderCollection()
            {
                { "Authorization", String.Format("Bearer {0}", AccessToken) }
            };
            method = method.ToUpper();
            url = apiRoot + url;

            var fetch = await HTTPFetchAsync(url, method, headers, body, contentType);
            VerboseCallback?.Invoke(fetch);
            return fetch;
        }

        protected static async Task<VerifyFeedback> VerifyAsync(string url)
        {
            WebHeaderCollection headers = new WebHeaderCollection();
            headers.Add("Content-Range: bytes */*");
            
            var responseHeaders = (await HTTPFetchAsync(url, "PUT", headers, "")).Fields;

            VerifyFeedback v = new VerifyFeedback();
            foreach (var item in responseHeaders)
            {
                if (item.StartsWith("Range:"))
                {
                    var s = item.Split(':')[1].Trim();
                    var rangestr = s.Split('=')[1].Split('-');
                    v.FirstByte = long.Parse(rangestr[0]);
                    v.LastByte = long.Parse(rangestr[1]);
                }
            }

            return v;
        }

        protected static async Task UploadAsync(
            string url,
            long contentLength,
            long startByte,
            byte[] payload)
        {
            WebHeaderCollection headers = new WebHeaderCollection();
            headers.Add(String.Format("Content-Range: bytes {0}-{1}/{2}",
                startByte, startByte + payload.Length, contentLength));
            
            var responseFromServer = await HTTPFetchAsync(
                url, "PUT", headers, payload, payload.Length, "video/mp4");

            Debug.WriteLine(String.Format("Response from URL {0}:", url), "Upload");
            Debug.WriteLine(responseFromServer, "Upload");
            if (VerboseCallback != null) VerboseCallback(responseFromServer);

        }

        protected static async Task<string> CompleteAsync(string url, WebHeaderCollection headers)
        {
            var response = await HTTPFetchAsync(
                url, "DELETE", headers, "",
                contentType: "application/x-www-form-urlencoded",
                requestAccept: "application/vnd.vimeo.*+json; version=3.2");

            string result = null;
            foreach (var item in response.Fields)
            {
                if (item.Contains("Location"))
                {
                    result = item.Split(':')[1].Trim();
                    break;
                }
            }

            Debug.WriteLine(String.Format("Response from URL {0}:", url), "Complete");
            Debug.WriteLine(result, "Complete");
            if (VerboseCallback != null) VerboseCallback(result);
            return result;
        }

        public async Task<Ticket> GetTicketAsync(string videoid = null, bool? upgrade_to_1080 = null)
        {
            var payload = new Dictionary<string, object>();
            payload["type"] = "streaming";
            if (upgrade_to_1080.HasValue) payload["upgrade_to_1080"] = upgrade_to_1080.Value.ToString().ToLower();
            if (!Core.IsNullOrWhiteSpace(videoid))
            {
                var endpoint = String.Format("/videos/{0}/files", videoid);
                var response = await RequestAsync(endpoint,payload,"PUT");
                return Ticket.FromJson(response);
            }
            else
            {
                var response = await RequestAsync("/me/videos",payload,"POST");
                return Ticket.FromJson(response);
            }
        }

        public async Task<string> UploadAsync(string path, Ticket ticket = null, 
            int chunkSize = Core.DEFAULT_CHUNK_SIZE, 
            int maxAttempts = Core.DEFAULT_MAX_ATTEMPTS, 
            long startByte = 0, bool step = false)
        {
            int attempts = 0;
            if (ticket == null) ticket = await GetTicketAsync();
            long contentLength = new FileInfo(path).Length;
            while (true)
            {
                var feedback = await VerifyAsync(ticket.UploadLinkSecure);
                startByte = feedback.LastByte;
                feedback.ContentSize = contentLength;
                if (VerboseCallback != null) VerboseCallback(String.Format("{0}/{1} Uploaded.", feedback.LastByte, contentLength));
                if (UploadCallback != null) UploadCallback(feedback);
                if (feedback.LastByte >= contentLength)
                {
                    Debug.WriteLine("Done!");
                    break;
                }

                try
                {
                    var payload = Core.GetPayload(path, startByte, chunkSize);
                    await UploadAsync(ticket.UploadLinkSecure, contentLength, startByte, payload);
                }
                catch (Exception e)
                {
                    attempts++;
                    if (attempts > maxAttempts)
                    {
                        Debug.WriteLine(e.Message, "Upload");
                        return null;
                    }
                }

                if (feedback.LastByte >= contentLength)
                {
                    Debug.WriteLine("Done!");
                    break;
                }
                if (step) return "";
            }
            
            var complete = await CompleteAsync(apiRoot + ticket.CompleteUri,
                new WebHeaderCollection()
                {
                    { "Authorization", String.Format("Bearer {0}", AccessToken) }
                });
            if (complete == null) throw new Exception("Complete Error");
            return complete;
        }
    }
}
